import matplotlib.pyplot as plt
#matplotlib.pyplot 각각의 함수를 사용해서 간편하게 그래프를 그리면서, 변화를 주는 모듈을 가져왔다.
import math
#수학적 함수를 이용하기 위한 math 모듈를 불러왔다.

plt.axis([0,100,0,150])
#축의 범위를 설정한다.
#axis([x값의 최소 범위, x값의 최대 범위 , y값의 최소 범위, y값의 최대 범위])의 형태로 X,Y축의 범위를 지정할 수 있다.
#축의 범위를 크게 넓혀서 이진 트리의 시각적 표현을 더욱 잘 보여주기 위해서 축의 범위를 x축은 100까지 늘렸고, y축은 150까지 늘렸다.
#만약 axis()함수에 입력값이 없으면 데이터에 맞게 자동으로 범위를 지정한다.

#DecisionTree
K = [1.,1.,1.,1.,1.,0.,0.,0.]
#완치 되었는지 안되었는지 구분하기 위한 리스트를 나열하였다.
#1 = Good을 의미하고, 0 = Bad를 의미한다.
#Good의 의미는 '완치 되었다.'는 뜻이고, Bad는 '완치되지 않고 죽었다.'라는 뜻이다.

C = [1.,1.,1.,1.,0.,0.,0.,0.]
#1행은 1 = o(복용 했다)을 의미하고, 0 = x(복용하지 않았다.)를 의미한다.
#2행은 1 = Good(완치 했다.)를 의미하고, 0 = Bad(죽었다.)라는 의미이다.
#o의 의미는 C약을 복용했다는 뜻이고, x의 의미는 C약을 복용하지 않았다 라는 뜻이다.

B = [1.,0.,1.,0.,1.,0.,1.,0.]
#1 = o(복용 했다)을 의미하고, 0 = x(복용하지 않았다.)를 의미한다. 
#o의 의미는 B약을 복용했다는 뜻이고, x의 의미는 B약을 복용하지 않았다 라는 뜻이다.

A = [1.,1.,0.,0.,1.,1.,0.,0.]
#1 = o(복용 했다)을 의미하고, 0 = x(복용하지 않았다.)를 의미한다. 
#o의 의미는 A약을 복용했다는 뜻이고, x의 의미는 A약을 복용하지 않았다 라는 뜻이다.


EntropySox = round((-(5/8) * math.log2(5/8)) + (-(3/8) * math.log2(3/8)),6)
#EntropySox = (-(5/8) * math.log2(5/8)) + (-(3/8) * math.log2(3/8))
#전체 엔트로피를 구하는 공식
#전체 약의 완치 했을때, 죽었을 때의 복잡도를 엔트로피 계산으로 측정한다.
#복잡도가 0 : 적을수록 정보 획득률은 좋아지고, 복잡도가 1 : 많을수록 정보획득률은 나쁘다.
#전체 데이터 8개 중 클래스가 G인 경우는 5 B인 경우는 3개이다.
EntropyCSo = round((-(4/4) * math.log2(4/4)) + 0, 6)
#C약을 복용 했을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#C약을 복용 했을 때의 엔트로피 값

EntropyCSx = round((-(1/4) * math.log2(1/4)) + (-(3/4) * math.log2(3/4)),6)
#C약을 복용하지 않았을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#C약을 복용하지 않았을 때의 엔트로피 값

GainSC = round(EntropySox +(-(4/8)*EntropyCSo) + (-(4/8)*EntropyCSx),6)
#C에 대한 정보 획득률을 나타낸다.
#GainSC(C에 대한 정보 획득률) : 전체 엔트로피 값 + (-(C약을 복용 했을 때 비율/전체 데이터)*C약을 복용 했을 때의 엔트로피 값)+(-(C약을 복용 하지 않았을 때 비율/전체 데이터)*C약을 복용하지 않았을 때의 엔트로피 값)
#복잡도가 0(0%)일 때면 정보 획득률은 좋아지고, 복잡도가 1(100%)일 때면 정보 획득률은 나쁘다.
#정보 획득률 : 복잡도를 최소화 시킬수 있는 정보가치를 의미한다.

EntropyBSo = round((-(3/4) * math.log2(3/4)) + (-(1/4) * math.log2(1/4)), 6)
#B약을 복용 했을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#B약을 복용 했을 때의 엔트로피 값

EntropyBSx = round((-(2/4) * math.log2(2/4)) + (-(2/4) * math.log2(2/4)),6)
#B약을 복용하지 않았을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#B약을 복용하지 않았을 때의 엔트로피 값

GainSB = round(EntropySox +(-(4/8)*EntropyBSo) + (-(4/8)*EntropyBSx),6)
#B에 대한 정보 획득률을 나타낸다.
#GainSB(B에 대한 정보 획득률) : 전체 엔트로피 값 + (-(B약을 복용 했을 때 비율/전체 데이터)*B약을 복용 했을 때의 엔트로피 값)+(-(B약을 복용 하지 않았을 때 비율/전체 데이터)*B약을 복용하지 않았을 때의 엔트로피 값)
#복잡도가 0(0%)일 때면 정보 획득률은 좋아지고, 복잡도가 1(100%)일 때면 정보 획득률은 나쁘다.
#정보 획득률 : 복잡도를 최소화 시킬수 있는 정보가치를 의미한다.


EntropyASo = round((-(3/4) * math.log2(3/4)) + (-(1/4) * math.log2(1/4)), 6)
#A약을 복용 했을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#A약을 복용 했을 때의 엔트로피 값

EntropyASx = round((-(2/4) * math.log2(2/4)) + (-(2/4) * math.log2(2/4)),6)
#A약을 복용하지 않았을 때 완치 했을때, 죽었을 때의 복잡도를 판별하는 것을 엔트로피 계산으로 측정한다.
#A약을 복용하지 않았을 때의 엔트로피 값

GainSA = round(EntropySox +(-(4/8)*EntropyBSo) + (-(4/8)*EntropyBSx),6)
#A에 대한 정보 획득률을 나타낸다.
#GainSA(A에 대한 정보 획득률) : 전체 엔트로피 값 + (-(A약을 복용 했을 때 비율/전체 데이터) * A약을 복용 했을 때의 엔트로피 값) + (-(A약을 복용 하지 않았을 때 비율/전체 데이터) * A약을 복용하지 않았을 때의 엔트로피 값)
#복잡도가 0(0%)일 때면 정보 획득률은 좋아지고, 복잡도가 1(100%)일 때면 정보 획득률은 나쁘다.
#정보 획득률 : 복잡도를 최소화 시킬수 있는 정보가치를 의미한다.
print("GainSA : ",GainSA)
print("GainSB : ",GainSB)
print("GainSC : ",GainSC)

if(GainSA>GainSB and GainSA>GainSC):#만약 A약의 정보 획득률이 가장 크다면
    RootNode = "A"#최상위 노드에 적힐 문자열 “A”를 저장한다.
elif(GainSB>GainSA and GainSB>GainSC):#만약 B약의 정보 획득률이 가장 크다면
    RootNode = "B"#최상위 노드에 적힐 문자열 “B”를 저장한다.
elif(GainSC>GainSA and GainSC>GainSB):#만약 C약의 정보 획득률이 가장 크다면
    RootNode = "C"#최상위 노드에 적힐 문자열 “C”를 저장한다.


plt.plot(50,135,color='#00FF00',marker='o',markersize='60',linestyle='')
#plot() 함수를 이용하여 맨 처음 C Node 또는 Root Node를 표시하기 위해서 그려주었다. 
#plt.plot(x값, y값, color = ‘16진수or색상’, marker = ‘마커의 종류‘, linestyle = ‘선의 종류’, markersize = ‘마커의 크기’, linewidth = ‘선의 굵기’, label = ‘그래프 라벨 이름’)
#1번째 인자 : 입력 데이터 값의 데이터 위치
#2번째 인자 : 출력 데이터 값의 데이터 위치
#3번째 인자 : 선의 색(검정색)
#4번째 인자 : 마커의 종류(o(원형 모양), ^(triangle_up(삼각형) 모양), s(정사각형 모양), p(오각형 모양),
#*(별 모양), h(육각형 모양), +(플러스 모양), d(다이아몬드 모양), _(언더바 모양))
#5번째 인자 : 선의 종류(‘-’: 실선 스타일,‘--’ : 파선 스타일,‘-.’ : Dash-Dot 선 스타일, ‘:’ : 점선 스타일)
#6번째 인자 : 마커의 크기
#7번째 인자 : 선의 굵기
#8번째 인자 : 해당 선의 의미를 알려주는 라벨의 이름
#Root Node의 데이터의 위치를 지정하고, 색은 초록색, 마커는 동그란원을 뜻하는 'o' 마커 사이즈는 60으로 설정하였다.

plt.annotate('{0}'.format(RootNode) ,xy=(37.3,107),xytext=(49.7,134.6), color = 'black', fontsize='9', arrowprops = dict(arrowstyle="-",color='black'))
#1번째 노드임을 알려주기 위해 annotate() 함수로 그래프에 주석을 그려주었다.
#이때 C Node와 그 밑에 있는 G를 연결시키기 위해서 실선으로 선을 연결을 시켜주는 그림을 그렸다.
#plt.annotate('문자열',xy = (x, y), xytext=(x, y), color = '색', fontsize = '크기', fontweight = '굵기', arrowprops = dict())
#arrowprops = dict(arrowstyle = "선 종류", color='선 색', linewidth = '선의 굵기', linestyle = '선의 종류', alpha = '선의 투명도')
#1번째 인자 : 문자열이나 문자를 입력해서 우리에게 그래프에 주석달아 시각적으로 보여줄 수 있는 인자이다.
#2번째 인자 : 표현하고 싶은 화살표의 위치를 의미한다. 
#3번째 인자 : 입력한 문자열의 위치를 의미한다. 기본 값은 'None'으로, None일 경우에는 'xy'와 동일한 위치에 주석이 표시된다.
#4번째 인자 : 문자열 폰트 색
#5번째 인자 : 문자열 폰트 크기
#6번째 인자 : 문자열 폰트 굵기
#arrowprops = dict() : 화살표의 속성을 지정하는 딕셔너리이다. 여기서 화살표의 스타일, 색상 등을 설정할 수 있다.
#화살표의 스타일 인자의 의미
#1번째 인자 : 화살표의 종류('simple or -|>' : 기본 화살표 스타일, <|- : 자신을 가리키는 기본 화살표 스타일, <|-|> : 양방향을 가리키는 기본 화살표 스타일,  'fancy' : 화살표의 촉이 얇고, 뒤는 굵은 스타일, 'wedge' : 못 같이 생긴 스타일,
# '-' : 실선 스타일, '->' : 촉이 얇은 화살표 스타일, <- : 자신을 가리키는 촉이 얇은 화살표 스타일, <-> : 양방향을 가르키는 촉이 얇은 화살표 스타일, '-[', ']-', ']-[', '|-|')
#2번째 인자 : 화살표의 선의 색
#3번째 인자 : 화살표의 선의 굵기
#4번째 인자 : 화살표의 선의 종류(‘-’: 실선 스타일,‘--’ : 파선 스타일,‘-.’ : Dash-Dot 선 스타일, ‘:’ : 점선 스타일)
#5번째 인자 : 화살표의 투명도 (0에서 1 사이의 값으로 설정된다.) 값이 1에 가까울수록 불투명해진다.

plt.annotate('Root Node',xy=(53,135),xytext=(65.21,134.3),fontsize='9',arrowprops = dict(color='black' ,arrowstyle="-|>"))
#현재 C Node가 부모 노드가 없고 최상위 노드임을 알려주기 위해 'Root Node'의 텍스트를 붙여주고, C Node와 연결되는 그림을 그려주었다.
plt.annotate('level 0 (depth 0)',xy=(47,135),xytext=(20.21,134.3),fontsize='9',arrowprops = dict(arrowstyle="-", color='black', linestyle ='--'))
#현재 level 0 또는 depth 0(깊이)를 나타내는 텍스트를 붙여주고, C Node의 현재 깊이가 level 0임을 알려주었다.

plt.plot(35,100,color='#0080FF',marker='s',markersize='50',linestyle='')
#plot() 함수를 이용하여 G(완치되었다.)를 표시하기 위해서 그려주었다. 
#데이터의 위치를 지정하고, 색은 연한 하늘색, 마커는 사각형을 뜻하는 's' 마커 사이즈는 50으로 설정하였다.
plt.annotate('O',(37,110),fontsize='13')
#약을 복용하였음을 보여주기 위해 annotate() 함수로 주석을 그려주었다.
plt.annotate('Good',(34.2,99),fontsize='9')
#완치 되었음을 알려주기 위해 annotate() 함수로 주석을 그려주었다.
plt.show()
#그래프의 그림을 보여주는 함수

